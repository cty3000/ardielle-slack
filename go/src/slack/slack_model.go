//
// This file generated by rdl 1.5.0
//

package slack

import (
	"encoding/json"
	"fmt"
	rdl "github.com/ardielle/ardielle-go/rdl"
)

var _ = rdl.Version
var _ = json.Marshal
var _ = fmt.Printf

//
// Event -
//
type Event struct {
	Type             string      `json:"type"`
	User             string      `json:"user,omitempty" rdl:"optional"`
	Deleted_ts       string      `json:"deleted_ts,omitempty" rdl:"optional"`
	Subtype          string      `json:"subtype,omitempty" rdl:"optional"`
	Hidden           *bool       `json:"hidden,omitempty" rdl:"optional"`
	Text             string      `json:"text,omitempty" rdl:"optional"`
	Channel          string      `json:"channel"`
	Previous_message *rdl.Struct `json:"previous_message,omitempty" rdl:"optional"`
	Item             *rdl.Struct `json:"item,omitempty" rdl:"optional"`
	Reaction         string      `json:"reaction,omitempty" rdl:"optional"`
	Item_user        string      `json:"item_user,omitempty" rdl:"optional"`
	Event_ts         string      `json:"event_ts"`
	Ts               string      `json:"ts"`
}

//
// NewEvent - creates an initialized Event instance, returns a pointer to it
//
func NewEvent(init ...*Event) *Event {
	var o *Event
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(Event)
	}
	return o
}

type rawEvent Event

//
// UnmarshalJSON is defined for proper JSON decoding of a Event
//
func (self *Event) UnmarshalJSON(b []byte) error {
	var m rawEvent
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := Event(m)
		*self = o
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *Event) Validate() error {
	if self.Type == "" {
		return fmt.Errorf("Event.type is missing but is a required field")
	} else {
		val := rdl.Validate(SlackSchema(), "String", self.Type)
		if !val.Valid {
			return fmt.Errorf("Event.type does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Channel == "" {
		return fmt.Errorf("Event.channel is missing but is a required field")
	} else {
		val := rdl.Validate(SlackSchema(), "String", self.Channel)
		if !val.Valid {
			return fmt.Errorf("Event.channel does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Event_ts == "" {
		return fmt.Errorf("Event.event_ts is missing but is a required field")
	} else {
		val := rdl.Validate(SlackSchema(), "String", self.Event_ts)
		if !val.Valid {
			return fmt.Errorf("Event.event_ts does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Ts == "" {
		return fmt.Errorf("Event.ts is missing but is a required field")
	} else {
		val := rdl.Validate(SlackSchema(), "String", self.Ts)
		if !val.Valid {
			return fmt.Errorf("Event.ts does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

//
// Challenge -
//
type Challenge struct {
	Token     string `json:"token"`
	Challenge string `json:"challenge"`
	Type      string `json:"type"`
}

//
// NewChallenge - creates an initialized Challenge instance, returns a pointer to it
//
func NewChallenge(init ...*Challenge) *Challenge {
	var o *Challenge
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(Challenge)
	}
	return o
}

type rawChallenge Challenge

//
// UnmarshalJSON is defined for proper JSON decoding of a Challenge
//
func (self *Challenge) UnmarshalJSON(b []byte) error {
	var m rawChallenge
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := Challenge(m)
		*self = o
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *Challenge) Validate() error {
	if self.Token == "" {
		return fmt.Errorf("Challenge.token is missing but is a required field")
	} else {
		val := rdl.Validate(SlackSchema(), "String", self.Token)
		if !val.Valid {
			return fmt.Errorf("Challenge.token does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Challenge == "" {
		return fmt.Errorf("Challenge.challenge is missing but is a required field")
	} else {
		val := rdl.Validate(SlackSchema(), "String", self.Challenge)
		if !val.Valid {
			return fmt.Errorf("Challenge.challenge does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Type == "" {
		return fmt.Errorf("Challenge.type is missing but is a required field")
	} else {
		val := rdl.Validate(SlackSchema(), "String", self.Type)
		if !val.Valid {
			return fmt.Errorf("Challenge.type does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

//
// Request - The events sent to your Request URL may contain sensitive
// information associated with the workspaces having approved your Slack app. To
// ensure that events are being delivered to a server under your direct control,
// we must verify your ownership by issuing you a challenge request.
//
type Request struct {
	Token        string   `json:"token"`
	Challenge    string   `json:"challenge,omitempty" rdl:"optional"`
	Team_id      string   `json:"team_id,omitempty" rdl:"optional"`
	Api_app_id   string   `json:"api_app_id,omitempty" rdl:"optional"`
	Event        *Event   `json:"event,omitempty" rdl:"optional"`
	Type         string   `json:"type"`
	Authed_users []string `json:"authed_users,omitempty" rdl:"optional"`
	Event_id     string   `json:"event_id,omitempty" rdl:"optional"`
	Event_time   *int32   `json:"event_time,omitempty" rdl:"optional"`
}

//
// NewRequest - creates an initialized Request instance, returns a pointer to it
//
func NewRequest(init ...*Request) *Request {
	var o *Request
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(Request)
	}
	return o
}

type rawRequest Request

//
// UnmarshalJSON is defined for proper JSON decoding of a Request
//
func (self *Request) UnmarshalJSON(b []byte) error {
	var m rawRequest
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := Request(m)
		*self = o
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *Request) Validate() error {
	if self.Token == "" {
		return fmt.Errorf("Request.token is missing but is a required field")
	} else {
		val := rdl.Validate(SlackSchema(), "String", self.Token)
		if !val.Valid {
			return fmt.Errorf("Request.token does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Type == "" {
		return fmt.Errorf("Request.type is missing but is a required field")
	} else {
		val := rdl.Validate(SlackSchema(), "String", self.Type)
		if !val.Valid {
			return fmt.Errorf("Request.type does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}
