//
// This file generated by rdl 1.5.0
//

package slack

import (
	"encoding/json"
	"fmt"
	rdl "github.com/ardielle/ardielle-go/rdl"
)

var _ = rdl.Version
var _ = json.Marshal
var _ = fmt.Printf

//
// Event -
//
type Event struct {
	Type             string      `json:"type"`
	User             string      `json:"user,omitempty" rdl:"optional"`
	Deleted_ts       string      `json:"deleted_ts,omitempty" rdl:"optional"`
	Subtype          string      `json:"subtype,omitempty" rdl:"optional"`
	Hidden           *bool       `json:"hidden,omitempty" rdl:"optional"`
	Text             string      `json:"text,omitempty" rdl:"optional"`
	Channel          string      `json:"channel"`
	Previous_message *rdl.Struct `json:"previous_message,omitempty" rdl:"optional"`
	Item             *rdl.Struct `json:"item,omitempty" rdl:"optional"`
	Reaction         string      `json:"reaction,omitempty" rdl:"optional"`
	Item_user        string      `json:"item_user,omitempty" rdl:"optional"`
	Event_ts         string      `json:"event_ts"`
	Ts               string      `json:"ts,omitempty" rdl:"optional"`
}

//
// NewEvent - creates an initialized Event instance, returns a pointer to it
//
func NewEvent(init ...*Event) *Event {
	var o *Event
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(Event)
	}
	return o
}

type rawEvent Event

//
// UnmarshalJSON is defined for proper JSON decoding of a Event
//
func (self *Event) UnmarshalJSON(b []byte) error {
	var m rawEvent
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := Event(m)
		*self = o
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *Event) Validate() error {
	if self.Type == "" {
		return fmt.Errorf("Event.type is missing but is a required field")
	} else {
		val := rdl.Validate(SlackSchema(), "String", self.Type)
		if !val.Valid {
			return fmt.Errorf("Event.type does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Channel == "" {
		return fmt.Errorf("Event.channel is missing but is a required field")
	} else {
		val := rdl.Validate(SlackSchema(), "String", self.Channel)
		if !val.Valid {
			return fmt.Errorf("Event.channel does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Event_ts == "" {
		return fmt.Errorf("Event.event_ts is missing but is a required field")
	} else {
		val := rdl.Validate(SlackSchema(), "String", self.Event_ts)
		if !val.Valid {
			return fmt.Errorf("Event.event_ts does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

//
// SlackEvent - The events sent to your Request URL may contain sensitive
// information associated with the workspaces having approved your Slack app. To
// ensure that events are being delivered to a server under your direct control,
// we must verify your ownership by issuing you a challenge request.
//
type SlackEvent struct {
	Token        string   `json:"token"`
	Challenge    string   `json:"challenge,omitempty" rdl:"optional"`
	Team_id      string   `json:"team_id,omitempty" rdl:"optional"`
	Api_app_id   string   `json:"api_app_id,omitempty" rdl:"optional"`
	Event        *Event   `json:"event,omitempty" rdl:"optional"`
	Type         string   `json:"type"`
	Authed_users []string `json:"authed_users,omitempty" rdl:"optional"`
	Event_id     string   `json:"event_id,omitempty" rdl:"optional"`
	Event_time   *int32   `json:"event_time,omitempty" rdl:"optional"`
}

//
// NewSlackEvent - creates an initialized SlackEvent instance, returns a pointer to it
//
func NewSlackEvent(init ...*SlackEvent) *SlackEvent {
	var o *SlackEvent
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(SlackEvent)
	}
	return o
}

type rawSlackEvent SlackEvent

//
// UnmarshalJSON is defined for proper JSON decoding of a SlackEvent
//
func (self *SlackEvent) UnmarshalJSON(b []byte) error {
	var m rawSlackEvent
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := SlackEvent(m)
		*self = o
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *SlackEvent) Validate() error {
	if self.Token == "" {
		return fmt.Errorf("SlackEvent.token is missing but is a required field")
	} else {
		val := rdl.Validate(SlackSchema(), "String", self.Token)
		if !val.Valid {
			return fmt.Errorf("SlackEvent.token does not contain a valid String (%v)", val.Error)
		}
	}
	if self.Type == "" {
		return fmt.Errorf("SlackEvent.type is missing but is a required field")
	} else {
		val := rdl.Validate(SlackSchema(), "String", self.Type)
		if !val.Valid {
			return fmt.Errorf("SlackEvent.type does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

//
// SlackWebhookURL -
//
type SlackWebhookURL string

//
// NgrokInterface -
//
type NgrokInterface struct {
	Public_url string `json:"public_url,omitempty" rdl:"optional"`
}

//
// NewNgrokInterface - creates an initialized NgrokInterface instance, returns a pointer to it
//
func NewNgrokInterface(init ...*NgrokInterface) *NgrokInterface {
	var o *NgrokInterface
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(NgrokInterface)
	}
	return o
}

type rawNgrokInterface NgrokInterface

//
// UnmarshalJSON is defined for proper JSON decoding of a NgrokInterface
//
func (self *NgrokInterface) UnmarshalJSON(b []byte) error {
	var m rawNgrokInterface
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := NgrokInterface(m)
		*self = o
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *NgrokInterface) Validate() error {
	return nil
}

//
// SlackWebhookRequest -
//
type SlackWebhookRequest struct {
	Text string `json:"text"`
}

//
// NewSlackWebhookRequest - creates an initialized SlackWebhookRequest instance, returns a pointer to it
//
func NewSlackWebhookRequest(init ...*SlackWebhookRequest) *SlackWebhookRequest {
	var o *SlackWebhookRequest
	if len(init) == 1 {
		o = init[0]
	} else {
		o = new(SlackWebhookRequest)
	}
	return o
}

type rawSlackWebhookRequest SlackWebhookRequest

//
// UnmarshalJSON is defined for proper JSON decoding of a SlackWebhookRequest
//
func (self *SlackWebhookRequest) UnmarshalJSON(b []byte) error {
	var m rawSlackWebhookRequest
	err := json.Unmarshal(b, &m)
	if err == nil {
		o := SlackWebhookRequest(m)
		*self = o
		err = self.Validate()
	}
	return err
}

//
// Validate - checks for missing required fields, etc
//
func (self *SlackWebhookRequest) Validate() error {
	if self.Text == "" {
		return fmt.Errorf("SlackWebhookRequest.text is missing but is a required field")
	} else {
		val := rdl.Validate(SlackSchema(), "String", self.Text)
		if !val.Valid {
			return fmt.Errorf("SlackWebhookRequest.text does not contain a valid String (%v)", val.Error)
		}
	}
	return nil
}

//
// SlackWebhookResponse -
//
type SlackWebhookResponse string
